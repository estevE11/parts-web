import { Player } from '@/interfaces/Player';
import { AbsoluteCenter, Box, Spinner, useToast } from '@chakra-ui/react'
import Head from 'next/head'
import { ChangeEvent, useEffect, useRef, useState } from 'react';
import { apiPOST } from '@/utils/apiUtils';
import SelectPlayerModal from '@/components/modals/SelectPlayerModal';
import { calculatePlayCount } from '@/utils/partsUtils';
import EditLineupModal from '@/components/modals/EditLineupModal';
import PlayCountList from '@/components/modules/PlayCountList';
import Header from '@/components/modules/Header';
import PartHeader from '../components/ui/PartHeader';

export default function Home() {
    const toast = useToast();
  
    const [players, setPlayers] = useState<Player[]>([]);
    const [parts, setParts] = useState<number[][]>(); // 2d number array containing player index
    const [playCount, setPlayCount] = useState<number[]>([]);
    const [warnings, setWarnings] = useState<number[][]>(new Array(4).fill(new Array(6).fill(0))); // 2d array containing part position info
    const [playedParts, setPlayedParts] = useState<number[][]>(new Array(20).fill(new Array(4).fill(0))); // 2d array containing part position info

    const [selectPlayerModalOpen, setSelectPlayerModalOpen] = useState(false);
    const [editLineupModalOpen, setEditLineupModalOpen] = useState(false);

    const [positionSelected, setPositionSelected] = useState([-1, -1]);

    const [generating, setGenerating] = useState(false);

    useEffect(() => {calculateMatchStats()}, [parts]);

    const loadFile = (e: ChangeEvent<HTMLInputElement>) => {
        const reader = new FileReader();
        reader.addEventListener('load', (event) => {
            if (event.target != undefined && event.target.result != undefined) {
                const fileObject = JSON.parse(event.target.result.toString());
                fileObject["players"].map((x: any, index: number) => {
                    x["id"] = index;
                    x["active"] = true;
                    return x;
                })
                setPlayers([...fileObject["players"]]);
            }
        })
        if (e.target.files != undefined)
            reader.readAsText(e.target.files[0]);
    }

    const generateMatch = () => {
        setParts(undefined);
        if (players.length <= 0) {
            toast({
                title: 'No team!',
                description: "You need to upload a team file before generating a match!",
                status: 'error',
                duration: 3000,
                isClosable: true,
            });
            return;
        }
        const body = {
            players: players,
            nParts: 4,
            nPlayers: 6
        };

        setGenerating(true);

        apiPOST('match', body).then((data: any) => {
            setGenerating(false);
            setParts([...data.parts]);
        });
    }

    const calculateMatchStats = () => {
        if (!parts) return;

        const stats = calculatePlayCount(parts, players);

        setPlayCount([...stats[0]]);
        setWarnings([...stats[1]]);
        setPlayedParts([...stats[2]]);
    }

    const updateSelectedPlayer = (newPlayerId: number) => {
        if (!parts) return;
        parts[positionSelected[0]][positionSelected[1]] = newPlayerId;
        setParts([...parts]);
        setSelectPlayerModalOpen(false);
    }

    const openSelectPlayerModal = (partN: number, posIndex: number) => {
        setPositionSelected([partN, posIndex]);
        setSelectPlayerModalOpen(true);
    }

    const copy = () => {
        let copyText = "";

        if (!parts) {
            toast({
                title: 'No match',
                description: "You need to generate a match to copy",
                status: 'error',
                duration: 3000,
                isClosable: true,
            });
            return;
        }

        for (let i = 0; i < parts.length; i++) { 
            copyText += `Part ${i+1}:\n`;
            for (let j = 0; j < parts[i].length; j++) { 
                const player = players[parts[i][j]];
                copyText += `${player.number} - ${player.name}\n`;
            }
            copyText += `\n`;
        }

        for (let i = 0; i < playCount.length; i++) {
            if (!players[i].active) continue;
            copyText += `${players[i].number} - ${players[i].name} played ${playCount[i]}\n`
        }

        navigator.clipboard.writeText(copyText);

        toast({
            title: 'Copied!',
            description: "Match copied to clipboard!",
            status: 'success',
            duration: 3000,
            isClosable: true,
        })
    }

    return (
        <>
            <Head>
                <title>PARTS</title> <meta name="description" content="Generated by create next app" />
                <meta name="viewport" content="width=device-width, initial-scale=1" />
                <link rel="icon" href="/favicon.ico" />
            </Head>

            <Box m={2}>
                <Header
                    players={players}
                    onEditLineup={() => { setEditLineupModalOpen(true) }}
                    onGenerateMatch={generateMatch}
                    onLoadFile={loadFile}
                    onCopy={copy}
                ></Header>
                <Box mt="2">
                    {generating &&
                        <AbsoluteCenter>
                            <Spinner size="xl" />
                        </AbsoluteCenter>

                    }
                    {parts && parts.map((part: number[], partNum) => (
                        <Box key={"part" + partNum}>
                            <PartHeader partNum={partNum}></PartHeader>
                            <table style={{marginRight: "10%", marginLeft: "10%"}}>
                                {part.map((playerIdx, index) => (
                                    <tr key={Math.random()} style={{backgroundColor: warnings[partNum][index] == 0 ? 'white' : '#ffcccc'}} onClick={() => { openSelectPlayerModal(partNum, index) }}>
                                        <td align='right'>
                                            { players[playerIdx].number }
                                        </td>
                                        <td style={{padding:8, paddingLeft: 10}}>
                                            { players[playerIdx].name }
                                        </td>
                                    </tr>
                                ))}
                            </table>
                        </Box>
                    ))}
                    { players.length > 0 && 
                        <PlayCountList
                            players={players}
                            playCount={playCount}
                            parts={parts ? parts : []}
                            playedParts={playedParts} 
                        ></PlayCountList>
                    }
                </Box>
            </Box>
            <SelectPlayerModal
                open={selectPlayerModalOpen}
                onClose={() => { setSelectPlayerModalOpen(false) }}
                onChange={ updateSelectedPlayer }
                players={ players }
                playCount={ playCount }
                changePosition={ positionSelected[1] }
                partPlayers={ parts && positionSelected[0] > -1 ? parts[positionSelected[0]] : []}
            ></SelectPlayerModal>
            <EditLineupModal
                open={editLineupModalOpen}
                onClose={() => { setEditLineupModalOpen(false); } }
                onChange={(players: Player[]) => (setPlayers([...players]))}
                _players={players}
            ></EditLineupModal>
        </>
    )
}
